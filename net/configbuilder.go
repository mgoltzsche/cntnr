package net

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/containernetworking/cni/pkg/types/current"
	"github.com/pkg/errors"
)

type ConfigFileGenerator struct {
	ip            string
	hostname      string
	dnsNameserver []string
	dnsSearch     []string
	dnsDomain     string
	dnsOptions    []string
	hosts         map[string]string
	hostsOrder    []string
}

func NewConfigFileGenerator() ConfigFileGenerator {
	return ConfigFileGenerator{
		dnsNameserver: []string{},
		dnsSearch:     []string{},
		dnsDomain:     "localdomain",
		dnsOptions:    []string{},
		hosts:         map[string]string{},
		hostsOrder:    []string{},
		ip:            "127.0.0.1",
	}
}

func (b *ConfigFileGenerator) AddCniResult(r *current.Result) {
	b.AddDnsNameserver(r.DNS.Nameservers)
	b.AddDnsOptions(r.DNS.Options)
	b.AddDnsSearch(r.DNS.Search)
	if r.DNS.Domain != "" {
		b.SetDnsDomain(r.DNS.Domain)
	}
	if len(r.IPs) > 0 {
		b.SetMainIP(r.IPs[0].Address.IP.String())
	}
}

func (b *ConfigFileGenerator) SetMainIP(ip string) {
	b.ip = ip
}

func (b *ConfigFileGenerator) SetHostname(hostname string) {
	b.hostname = hostname
}

func (b *ConfigFileGenerator) SetDnsDomain(domain string) {
	b.dnsDomain = domain
}

func (b *ConfigFileGenerator) AddHostsEntry(host, ip string) {
	b.hostsOrder = append(b.hostsOrder, host)
	b.hosts[host] = ip
}

func (b *ConfigFileGenerator) AddDnsNameserver(dns []string) {
	if len(dns) > 0 {
		b.dnsNameserver = append(b.dnsNameserver, dns...)
	}
}

func (b *ConfigFileGenerator) AddDnsSearch(searchSuffix []string) {
	if len(searchSuffix) > 0 {
		b.dnsSearch = append(b.dnsSearch, searchSuffix...)
	}
}

func (b *ConfigFileGenerator) AddDnsOptions(opts []string) {
	if len(opts) > 0 {
		b.dnsOptions = append(b.dnsOptions, opts...)
	}
}

func (b *ConfigFileGenerator) WriteConfigFiles(rootfs, overlay string) error {
	hostnameFile := filepath.Join(overlay, "etc", "hostname")
	hostsFile := filepath.Join(overlay, "etc", "hosts")
	resolvConfFile := filepath.Join(overlay, "etc", "resolv.conf")

	// Write /etc/hostname
	hostname := b.hostname
	if hostname != "" {
		if err := writeFile(hostnameFile, hostname+"\n"); err != nil {
			return errors.Wrap(err, "write container's hostname file")
		}
	}

	// Write /etc/resolv.conf if value set
	// TODO: apply existing resolv.conf first
	if err := b.writeResolvConf(resolvConfFile); err != nil {
		return err
	}

	// Write /etc/hosts if not empty
	// TODO: apply existing hosts first
	return b.writeHosts(hostsFile)
}

func (b *ConfigFileGenerator) writeResolvConf(dest string) error {
	rc := ""

	for _, ns := range b.dnsNameserver {
		rc += "nameserver " + ns + "\n"
	}

	for _, s := range b.dnsSearch {
		rc += "search " + s + "\n"
	}

	if b.dnsDomain != "" {
		rc += "domain " + b.dnsDomain + "\n"
	}

	if len(b.dnsOptions) > 0 {
		rc += "options " + strings.Join(b.dnsOptions, " ") + "\n"
	}

	if rc != "" {
		rc = "# Generated by " + os.Args[0] + "\n" + rc
		return writeFile(dest, rc)
	}
	return nil
}

func (b *ConfigFileGenerator) writeHosts(dest string) error {
	if len(b.hosts) == 0 && b.hostname == "" {
		return nil
	}

	hosts := map[string]string{
		"127.0.0.1": "localhost localhost.localdomain localhost.domain localhost4 localhost4.localdomain4",
		"::1":       "ip6-localhost ip6-loopback localhost6 localhost6.localdomain6",
		"fe00::0":   "ip6-localnet",
		"ff00::0":   "ip6-mcastprefix",
		"ff02::1":   "ip6-allnodes",
		"ff02::2":   "ip6-allrouters",
		"ff02::3":   "ip6-allhosts",
	}
	if b.ip != "" && b.hostname != "" {
		hostname := b.hostname
		dotPos := strings.Index(hostname, ".")
		if dotPos > 0 && dotPos+1 < len(b.hostname) {
			hostname = hostname + " " + hostname[:dotPos]
		}
		hosts[b.ip] = strings.Trim(hostname+" "+hosts[b.ip], " ")
	}
	for _, name := range b.hostsOrder {
		ip := b.hosts[name]
		hosts[ip] = strings.Trim(hosts[ip]+" "+name, " ")
	}
	entries := make([]string, len(hosts))
	i := 0
	for ip, names := range hosts {
		entries[i] = fmt.Sprintf("%-15s  %s", ip, names)
		i++
	}
	sort.Strings(entries)

	hc := "# Generated by " + os.Args[0] + "\n" + strings.Join(entries, "\n") + "\n"
	err := writeFile(dest, hc)
	if err != nil {
		return errors.Wrap(err, "write container's hosts file")
	}
	return nil
}

func writeFile(dest, content string) error {
	f, err := os.OpenFile(dest, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		if os.IsNotExist(err) {
			errors.Errorf("file %s does not exist. needs to exist and bind mounted into the containers's rootfs", dest)
		} else {
			return err
		}
	}
	if _, err := f.Write([]byte(content)); err != nil {
		f.Close()
		return err
	}
	return f.Close()
}
